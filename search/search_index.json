{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RepoAuditor RepoAuditor is a handy tool which audits repositories for best practices. It helps maintain high-quality and consistent open-source repositories even if you are new to maintaining open-source software. Contents Installation How to use RepoAuditor Personal Access Token Example Usage Config File Development Additional Information License Installation We recommend using uv since it can install RepoAuditor as a tool via uvx into a sandbox environment for quick use. This lets you directly run RepoAuditor . uvx RepoAuditor Alternatively, yuou can install RepoAuditor via uv or pip . uv is preferred to pip since it creates and manages a virtual environment. Installation Method Command Via uv uv add repoauditor Via pip pip install repoauditor How To Use Once installed, you can invoke the following to verify if RepoAuditor is installed correctly: uvx RepoAuditor --version and you should see something like RepoAuditor vX.X.X To get a list of command line options, you can run uvx RepoAuditor --help In order to use RepoAuditor with GitHub, you will need a Personal Access Token (or PAT for short). Let's go over how to generate a PAT next .","title":"Home"},{"location":"#repoauditor","text":"RepoAuditor is a handy tool which audits repositories for best practices. It helps maintain high-quality and consistent open-source repositories even if you are new to maintaining open-source software.","title":"RepoAuditor"},{"location":"#contents","text":"Installation How to use RepoAuditor Personal Access Token Example Usage Config File Development Additional Information License","title":"Contents"},{"location":"#installation","text":"We recommend using uv since it can install RepoAuditor as a tool via uvx into a sandbox environment for quick use. This lets you directly run RepoAuditor . uvx RepoAuditor Alternatively, yuou can install RepoAuditor via uv or pip . uv is preferred to pip since it creates and manages a virtual environment. Installation Method Command Via uv uv add repoauditor Via pip pip install repoauditor","title":"Installation"},{"location":"#how-to-use","text":"Once installed, you can invoke the following to verify if RepoAuditor is installed correctly: uvx RepoAuditor --version and you should see something like RepoAuditor vX.X.X To get a list of command line options, you can run uvx RepoAuditor --help In order to use RepoAuditor with GitHub, you will need a Personal Access Token (or PAT for short). Let's go over how to generate a PAT next .","title":"How To Use"},{"location":"CONTRIBUTING/","text":"Contribution Guidelines Additional information is available at the following locations. Topic Description Location Code of Conduct How we welcome others to this community. CODE_OF_CONDUCT.md Development Activities How we create software in this community. DEVELOPMENT.md Security How to report vulnerabilities in our software. SECURITY.md Bug Reports If you experience a problem with our software, please visit issues and create a Bug report . Feature Requests If you would like to suggest a new feature for our software, please visit issues and create a Feature request . Issue Labels We use these labels to help us track and manage Bug reports and Feature requests . Label Description bug Something isn't working. enhancement New feature or request. help wanted Extra attention is needed. good first issue Good for newcomers. documentation Improvements or additions to documentation. General Information For specific proposals, please provide them as pull requests or issues via our GitHub site . The DEVELOPMENT.md file explains how to install the program locally (highly recommended if you're going to make code changes). It also provides information useful for making changes and validating them locally before submitting a pull request. Pull requests and different branches recommended Pull requests are preferred, since they are specific. For more about how to create a pull request, see https://help.github.com/articles/using-pull-requests/. We recommend creating different branches for different (logical) changes, and creating a pull request into the main branch when you're done. See the GitHub documentation on creating branches and using pull requests . How we handle proposals We use GitHub to track proposed changes via its issue tracker and pull requests . Specific changes are proposed using those mechanisms. Issues are assigned to an individual, who works and then marks it complete. If there are questions or objections, the conversation of that issue or pull request is used to resolve it. We are proactive In general we try to be proactive to detect and eliminate mistakes and vulnerabilities as soon as possible, and to reduce their impact when they do happen. We use a defensive design and coding style to reduce the likelihood of mistakes, a variety of tools that try to detect mistakes early, and an automatic test suite with significant coverage. We also release the software as open source software so others can review it. Since early detection and impact reduction can never be perfect, we also try to detect and repair problems during deployment as quickly as possible. This is especially true for security issues; see our security information for more information. Vulnerability reporting (security issues) Please privately report vulnerabilities you find so we can fix them! See SECURITY.md for information on how to privately report vulnerabilities. Acknowledgements This Code of Conduct is adapted from the Contributor Covenant , version 1.0.0, available at http://contributor-covenant.org/version/1/0/0/","title":"Contributing"},{"location":"CONTRIBUTING/#contribution-guidelines","text":"Additional information is available at the following locations. Topic Description Location Code of Conduct How we welcome others to this community. CODE_OF_CONDUCT.md Development Activities How we create software in this community. DEVELOPMENT.md Security How to report vulnerabilities in our software. SECURITY.md","title":"Contribution Guidelines"},{"location":"CONTRIBUTING/#bug-reports","text":"If you experience a problem with our software, please visit issues and create a Bug report .","title":"Bug Reports"},{"location":"CONTRIBUTING/#feature-requests","text":"If you would like to suggest a new feature for our software, please visit issues and create a Feature request .","title":"Feature Requests"},{"location":"CONTRIBUTING/#issue-labels","text":"We use these labels to help us track and manage Bug reports and Feature requests . Label Description bug Something isn't working. enhancement New feature or request. help wanted Extra attention is needed. good first issue Good for newcomers. documentation Improvements or additions to documentation.","title":"Issue Labels"},{"location":"CONTRIBUTING/#general-information","text":"For specific proposals, please provide them as pull requests or issues via our GitHub site . The DEVELOPMENT.md file explains how to install the program locally (highly recommended if you're going to make code changes). It also provides information useful for making changes and validating them locally before submitting a pull request.","title":"General Information"},{"location":"CONTRIBUTING/#pull-requests-and-different-branches-recommended","text":"Pull requests are preferred, since they are specific. For more about how to create a pull request, see https://help.github.com/articles/using-pull-requests/. We recommend creating different branches for different (logical) changes, and creating a pull request into the main branch when you're done. See the GitHub documentation on creating branches and using pull requests .","title":"Pull requests and different branches recommended"},{"location":"CONTRIBUTING/#how-we-handle-proposals","text":"We use GitHub to track proposed changes via its issue tracker and pull requests . Specific changes are proposed using those mechanisms. Issues are assigned to an individual, who works and then marks it complete. If there are questions or objections, the conversation of that issue or pull request is used to resolve it.","title":"How we handle proposals"},{"location":"CONTRIBUTING/#we-are-proactive","text":"In general we try to be proactive to detect and eliminate mistakes and vulnerabilities as soon as possible, and to reduce their impact when they do happen. We use a defensive design and coding style to reduce the likelihood of mistakes, a variety of tools that try to detect mistakes early, and an automatic test suite with significant coverage. We also release the software as open source software so others can review it. Since early detection and impact reduction can never be perfect, we also try to detect and repair problems during deployment as quickly as possible. This is especially true for security issues; see our security information for more information.","title":"We are proactive"},{"location":"CONTRIBUTING/#vulnerability-reporting-security-issues","text":"Please privately report vulnerabilities you find so we can fix them! See SECURITY.md for information on how to privately report vulnerabilities.","title":"Vulnerability reporting (security issues)"},{"location":"CONTRIBUTING/#acknowledgements","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.0.0, available at http://contributor-covenant.org/version/1/0/0/","title":"Acknowledgements"},{"location":"DEVELOPMENT/","text":"Development Guide Fork setup Step Command Line Additional Information 1. Fork the repository -- Fork Link 2. Create a PAT for your forked repository -- See PAT setup instructions 3. Update your forked repository settings to match RepoAuditor's defaults -- -- Local Development Enlistment Step Command Line Additional Information 1. Clone the repository locally. git clone https://github.com/gt-sse-center/RepoAuditor git-clone docs 2. Install uv . curl -LsSf https://astral.sh/uv/install.sh \\| sh on macOS and Linux or powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 \\| iex\" on Windows https://docs.astral.sh 3. Install dependencies. uv sync Astral uv sync docs 4. Install pre-commit hooks uv run pre-commit install Install pre-commit 5. If you wish to test against an enterprise server, add a remote named enterprise with the corresponding URL E.g. git remote add enterprise git@github.gatech.edu:sse-center/RepoAuditor.git Setup Basic Setup Please follow these steps to allow for local testing. Fork the RepoAuditor repository. We will test against the fork since your generated PAT is applicable only for the fork. Create a PAT file as detailed in the README . Set your forked repository as the origin remote (this should already be the case but it's good to verify). git remote add origin git@github.com:<github-username>/RepoAuditor.git Update the URL in default_config.yaml to point to your fork. You should now be able to run the following and see valid output. There will be errors, which we will tackle next. uv run RepoAuditor --config default_config.yaml --GitHub-pat PAT.txt Local Testing You can now run local tests from the project root directory with uv run pytest -k 'not EndToEndTest' End-To-End Testing To include tests against your RepoAuditor fork for comprehensive end-to-end testing, you can run: uv run pytest In order to run end-to-end tests, which make calls to the GitHub API, you need to configure your forked repository, else you will see a large number of test failures. Please follow the steps below to complete the configuration. On the General settings page Under Features Check Wikis . Check Issues . Check Projects . Under Pull Requests With Allow merge commits , set the Default commit message to Pull request title . Uncheck Allow squash merging . Uncheck Allow rebase merging . Check Allow auto-merge . Check Automatically delete head branches . On the Branches settings page Click Add classic branch protection rule . Under Branch name pattern , type in main . Check Require a pull request before merging . Check Require a pull request before merging -> Require approvals . Check Require a pull request before merging -> Dismiss stale pull request approvals when new commits are pushed . Check Require a pull request before merging -> Require approval of the most recent reviewable push . Under Protect matching branches Check Require status checks to pass before merging . Check Require status checks to pass before merging -> Require branches to be up to date before merging . Add the CI+CD Workflow / Validate (ubuntu-latest, 3.13) or an equivalent status check. Check Require conversation resolution before merging . Check Require signed commits . Check Do not allow bypassing the above settings . On the Advanced Security settings page Enable Dependabot security updates . Go to the Actions tab Enable Workflows by clicking on I understand my workflows, go ahead and enable them . Run the CI+CD workflow. You will be asked to enable it, please do so. In the Run workflow dropdown to the right, click the Run workflow button. This should cause the action to run, don't worry if it fails, it is only needed for a check below. On the Rules -> Rulesets settings page, create a new branch ruleset called main : Under Target branches , click Add target -> Include by pattern and type in main . Finalize by clicking Add Inclusion pattern . Enable Restrict deletions Enable Require signed commits Enable Require a pull request before merging with 1 required approval. Enable Dismiss stale pull request approvals when new commits are pushed . Enable Require approval of the most recent reviewable push . Enable Require conversation resolution before merging . Enable Require status checks to pass . Enable Require branches to be up to date before merging . Set the CI+CD Workflow / Validate (ubuntu-latest, 3.12) or an equivalent check. Disable Block force pushes . Be sure to hit Save changes at the end. Development Activities Activity Command Line Description Used During Local Development Invoked by Continuous Integration Code Formatting uv run ruff format or uv run ruff format --check Format source code using ruff based on settings in pyproject.toml . :white_check_mark: :white_check_mark: (via pre-commit ) Sort Imports uv run ruff check --fix --select I Sort imports in source files. :white_check_mark: Static Code Analysis uv run ruff check Validate source code using ruff based on settings in pyproject.toml . :white_check_mark: :white_check_mark: (via pre-commit ) Run pre-commit scripts uv run pre-commit run Run pre-commit scripts based on settings in .pre-commit-config.yaml . :white_check_mark: :white_check_mark: Automated Testing uv run pytest or uv run pytest --no-cov Run automated tests using pytest and extract code coverage using coverage based on settings in pyproject.toml . :white_check_mark: :white_check_mark: Semantic Version Generation uv run python -m AutoGitSemVer.scripts.UpdatePythonVersion ./src/RepoAuditor/__init__.py ./src Generate a new Semantic Version based on git commits using AutoGitSemVer . Version information is stored in ./src/RepoAuditor/__init__.py . :white_check_mark: Python Package Creation uv build Create a python package using uv based on settings in pyproject.toml . Generated packages will be written to ./dist . :white_check_mark: Sign Artifacts uv run --with py-minisign python -c \"import minisign; minisign.SecretKey.from_file(<temp_filename>).sign_file(<filename>, trusted_comment='<package_name> v<package_version>', drop_signature=True) Signs artifacts using py-minisign . Note that the private key is stored as a GitHub secret . :white_check_mark: Python Package Publishing uv publish Publish a python package to PyPi using uv based on settings in pyproject.toml . :white_check_mark: Contributing Changes Pull requests are preferred, since they are specific. For more about how to create a pull request, see this guide . We recommend creating different branches for different (logical) changes, and creating a pull request into the main branch when you're done. For more information on creating branches, please see this GitHub guide . Verifying Signed Artifacts Artifacts are signed and validated using py-minisign and the public key in the file ./minisign_key.pub . To verify that an artifact is valid, visit the latest release and download the .minisign signature file that corresponds to the artifact, then run the following command, replacing <filename> with the name of the artifact to be verified: uv run --with py-minisign python -c \"import minisign; minisign.PublicKey.from_file('minisign_key.pub').verify_file('<filename>')\"","title":"Development"},{"location":"DEVELOPMENT/#development-guide","text":"","title":"Development Guide"},{"location":"DEVELOPMENT/#fork-setup","text":"Step Command Line Additional Information 1. Fork the repository -- Fork Link 2. Create a PAT for your forked repository -- See PAT setup instructions 3. Update your forked repository settings to match RepoAuditor's defaults -- --","title":"Fork setup"},{"location":"DEVELOPMENT/#local-development","text":"","title":"Local Development"},{"location":"DEVELOPMENT/#enlistment","text":"Step Command Line Additional Information 1. Clone the repository locally. git clone https://github.com/gt-sse-center/RepoAuditor git-clone docs 2. Install uv . curl -LsSf https://astral.sh/uv/install.sh \\| sh on macOS and Linux or powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 \\| iex\" on Windows https://docs.astral.sh 3. Install dependencies. uv sync Astral uv sync docs 4. Install pre-commit hooks uv run pre-commit install Install pre-commit 5. If you wish to test against an enterprise server, add a remote named enterprise with the corresponding URL E.g. git remote add enterprise git@github.gatech.edu:sse-center/RepoAuditor.git","title":"Enlistment"},{"location":"DEVELOPMENT/#setup","text":"","title":"Setup"},{"location":"DEVELOPMENT/#basic-setup","text":"Please follow these steps to allow for local testing. Fork the RepoAuditor repository. We will test against the fork since your generated PAT is applicable only for the fork. Create a PAT file as detailed in the README . Set your forked repository as the origin remote (this should already be the case but it's good to verify). git remote add origin git@github.com:<github-username>/RepoAuditor.git Update the URL in default_config.yaml to point to your fork. You should now be able to run the following and see valid output. There will be errors, which we will tackle next. uv run RepoAuditor --config default_config.yaml --GitHub-pat PAT.txt","title":"Basic Setup"},{"location":"DEVELOPMENT/#local-testing","text":"You can now run local tests from the project root directory with uv run pytest -k 'not EndToEndTest'","title":"Local Testing"},{"location":"DEVELOPMENT/#end-to-end-testing","text":"To include tests against your RepoAuditor fork for comprehensive end-to-end testing, you can run: uv run pytest In order to run end-to-end tests, which make calls to the GitHub API, you need to configure your forked repository, else you will see a large number of test failures. Please follow the steps below to complete the configuration. On the General settings page Under Features Check Wikis . Check Issues . Check Projects . Under Pull Requests With Allow merge commits , set the Default commit message to Pull request title . Uncheck Allow squash merging . Uncheck Allow rebase merging . Check Allow auto-merge . Check Automatically delete head branches . On the Branches settings page Click Add classic branch protection rule . Under Branch name pattern , type in main . Check Require a pull request before merging . Check Require a pull request before merging -> Require approvals . Check Require a pull request before merging -> Dismiss stale pull request approvals when new commits are pushed . Check Require a pull request before merging -> Require approval of the most recent reviewable push . Under Protect matching branches Check Require status checks to pass before merging . Check Require status checks to pass before merging -> Require branches to be up to date before merging . Add the CI+CD Workflow / Validate (ubuntu-latest, 3.13) or an equivalent status check. Check Require conversation resolution before merging . Check Require signed commits . Check Do not allow bypassing the above settings . On the Advanced Security settings page Enable Dependabot security updates . Go to the Actions tab Enable Workflows by clicking on I understand my workflows, go ahead and enable them . Run the CI+CD workflow. You will be asked to enable it, please do so. In the Run workflow dropdown to the right, click the Run workflow button. This should cause the action to run, don't worry if it fails, it is only needed for a check below. On the Rules -> Rulesets settings page, create a new branch ruleset called main : Under Target branches , click Add target -> Include by pattern and type in main . Finalize by clicking Add Inclusion pattern . Enable Restrict deletions Enable Require signed commits Enable Require a pull request before merging with 1 required approval. Enable Dismiss stale pull request approvals when new commits are pushed . Enable Require approval of the most recent reviewable push . Enable Require conversation resolution before merging . Enable Require status checks to pass . Enable Require branches to be up to date before merging . Set the CI+CD Workflow / Validate (ubuntu-latest, 3.12) or an equivalent check. Disable Block force pushes . Be sure to hit Save changes at the end.","title":"End-To-End Testing"},{"location":"DEVELOPMENT/#development-activities","text":"Activity Command Line Description Used During Local Development Invoked by Continuous Integration Code Formatting uv run ruff format or uv run ruff format --check Format source code using ruff based on settings in pyproject.toml . :white_check_mark: :white_check_mark: (via pre-commit ) Sort Imports uv run ruff check --fix --select I Sort imports in source files. :white_check_mark: Static Code Analysis uv run ruff check Validate source code using ruff based on settings in pyproject.toml . :white_check_mark: :white_check_mark: (via pre-commit ) Run pre-commit scripts uv run pre-commit run Run pre-commit scripts based on settings in .pre-commit-config.yaml . :white_check_mark: :white_check_mark: Automated Testing uv run pytest or uv run pytest --no-cov Run automated tests using pytest and extract code coverage using coverage based on settings in pyproject.toml . :white_check_mark: :white_check_mark: Semantic Version Generation uv run python -m AutoGitSemVer.scripts.UpdatePythonVersion ./src/RepoAuditor/__init__.py ./src Generate a new Semantic Version based on git commits using AutoGitSemVer . Version information is stored in ./src/RepoAuditor/__init__.py . :white_check_mark: Python Package Creation uv build Create a python package using uv based on settings in pyproject.toml . Generated packages will be written to ./dist . :white_check_mark: Sign Artifacts uv run --with py-minisign python -c \"import minisign; minisign.SecretKey.from_file(<temp_filename>).sign_file(<filename>, trusted_comment='<package_name> v<package_version>', drop_signature=True) Signs artifacts using py-minisign . Note that the private key is stored as a GitHub secret . :white_check_mark: Python Package Publishing uv publish Publish a python package to PyPi using uv based on settings in pyproject.toml . :white_check_mark:","title":"Development Activities"},{"location":"DEVELOPMENT/#contributing-changes","text":"Pull requests are preferred, since they are specific. For more about how to create a pull request, see this guide . We recommend creating different branches for different (logical) changes, and creating a pull request into the main branch when you're done. For more information on creating branches, please see this GitHub guide .","title":"Contributing Changes"},{"location":"DEVELOPMENT/#verifying-signed-artifacts","text":"Artifacts are signed and validated using py-minisign and the public key in the file ./minisign_key.pub . To verify that an artifact is valid, visit the latest release and download the .minisign signature file that corresponds to the artifact, then run the following command, replacing <filename> with the name of the artifact to be verified: uv run --with py-minisign python -c \"import minisign; minisign.PublicKey.from_file('minisign_key.pub').verify_file('<filename>')\"","title":"Verifying Signed Artifacts"},{"location":"PAT/","text":"Personal Access Token (PAT) The most common use case for RepoAuditor would be to audit a GitHub repository. In order to allow RepoAuditor to read the repository, you first need to generate a Personal Access Token or PAT . Please refer to the GitHub documentation on Personal Access Tokens for details about a Fine-grained PAT which we will be using. To generate the Fine-grained PAT, we perform the following steps: Go to Settings -> Developer settings -> Personal Access Token -> Fine-grained tokens . Click on Generate new token . Give the token a name and a description. Set an appropriate expiration date. Under Repository Access , select All repositories . For permissions, we need to go to Repository permissions . Enable the following permissions: Read-Write access to Contents . Read access to Administration and Secret scanning alerts . Click on Generate token . Copy the generated string. This is your PAT. Save the PAT to a convenient location on your machine (such as your home directory ~/ ) in the file PAT.txt . The path to the PAT.txt will be passed into RepoAuditor . E.g. uvx RepoAuditor --GitHub-pat ~/PAT.txt","title":"PAT"},{"location":"PAT/#personal-access-token-pat","text":"The most common use case for RepoAuditor would be to audit a GitHub repository. In order to allow RepoAuditor to read the repository, you first need to generate a Personal Access Token or PAT . Please refer to the GitHub documentation on Personal Access Tokens for details about a Fine-grained PAT which we will be using. To generate the Fine-grained PAT, we perform the following steps: Go to Settings -> Developer settings -> Personal Access Token -> Fine-grained tokens . Click on Generate new token . Give the token a name and a description. Set an appropriate expiration date. Under Repository Access , select All repositories . For permissions, we need to go to Repository permissions . Enable the following permissions: Read-Write access to Contents . Read access to Administration and Secret scanning alerts . Click on Generate token . Copy the generated string. This is your PAT. Save the PAT to a convenient location on your machine (such as your home directory ~/ ) in the file PAT.txt . The path to the PAT.txt will be passed into RepoAuditor . E.g. uvx RepoAuditor --GitHub-pat ~/PAT.txt","title":"Personal Access Token (PAT)"},{"location":"config_file/","text":"Configuration File RepoAuditor accepts both a set of flags as well as a configuration YAML file. The configuration (or config) file can make usage easier by recording preferences as well as facilitating sharing of enforced requirements within an organization. We have provided a sample configuration file called default_config.yaml , which can be used as: uvx run RepoAuditor --config default_config.yaml","title":"Config File"},{"location":"config_file/#configuration-file","text":"RepoAuditor accepts both a set of flags as well as a configuration YAML file. The configuration (or config) file can make usage easier by recording preferences as well as facilitating sharing of enforced requirements within an organization. We have provided a sample configuration file called default_config.yaml , which can be used as: uvx run RepoAuditor --config default_config.yaml","title":"Configuration File"},{"location":"troubleshooting/","text":"Troubleshooting Guide","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting-guide","text":"","title":"Troubleshooting Guide"},{"location":"usage/","text":"Usage Basic Use With a generated PAT file, you can now run RepoAuditor on your GitHub repository. uvx repoauditor --includes GitHub \\ --GitHub-url <url-to-repo> \\ --GitHub-pat ~/PAT.txt If your repository is on an enterprise server, you can similarly generate a PAT (and save it enterprise_PAT.txt ) and point RepoAuditor to the corresponding repo: uvx repoauditor --includes GitHub \\ --GitHub-url <url-to-enterprise-repo> \\ --GitHub-pat ~/enterprise_PAT.txt As a general example, we will use the python-helloworld repository. NOTE You need to fork the repository since your default PAT only has access to repos under your account. To run RepoAuditor , we can enter the following in the command-line: uvx repoauditor --includes GitHub \\ --GitHub-url https://github.com/<username>/python-helloworld \\ --GitHub-pat ~/PAT.txt RepoAuditor will generate a series of messages describing all the issues in the repository, along with the rationale behind them and the steps for resolution. Custom Settings RepoAuditor tries to provide default settings and checks which are considered best practices. However, your team or organization may have different ways of doing things. You can override the default settings by specifying the appropriate flag. We have 3 types of flags: Boolean flags for those settings which are checked to be on by default and you wish to check are off, with the form Module-no-Requirement (e.g. --GitHub-no-MergeCommit ). Conversely, boolean flags for those settings which are checked to be off by default, and you wish to check are on, denoted by the form Module-Requirement (e.g. --GitHub-AllowDeletions ). Values flags take a string value to determine what value to enforce, and have the form Module-Requirement-value (e.g. --GitHub-License-value \"MIT License\" ). Please run uvx repoauditor --help to get the list of all flags available. Examples In this section, we will look at various exampls of using RepoAuditor . For the sake of brevity, we will omit the --includes and --GitHub-url flags, leaving the inclusion to the user. RepoAuditor is designed to have sensible defaults which represent industry best practices. For example, RepoAuditor by default checks that the setting Allow rebase merging is off. However, if you wish to check that this setting is turned on, you can run: uvx repoauditor --GitHub-RebaseMergeCommit Similarly, RepoAuditor checks if Issues are enabled. You can set RepoAuditor to check if Issues is disabled by specifying uvx repoauditor --GitHub-no-SupportIssues Finally, RepoAuditor by default enforces that the MIT License exists for the repository. If your organization requires another license (such as GPL ), you can enforce that by specifying the license keyword such as: uvx repoauditor --GitHub-License-value \"GNU General Public License v2.0\" The types of licenses supported by GitHub can be found here . Be sure to specify the full license name, e.g. GNU General Public License v2.0 . Excluding Requirements There is often the case you might wish to exclude a module or a specific requirement. RepoAuditor has built-in support for this as well, by using the --excludes flag. To exclude a requirement, you can run specify the requirement as Module-Requirement uvx repoauditor --includes GitHub --excludes GitHub-RequireSignedCommitsRule The above command includes all of the requirements in the GitHub module except for the RequireSignedCommitsRule requirement. You can similarly exclude a whole module: uvx repoauditor --includes GitHub --excludes CommunityStandards NOTE: This way of excluding a module is redundant since any module not added via --includes is automatically excluded.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#basic-use","text":"With a generated PAT file, you can now run RepoAuditor on your GitHub repository. uvx repoauditor --includes GitHub \\ --GitHub-url <url-to-repo> \\ --GitHub-pat ~/PAT.txt If your repository is on an enterprise server, you can similarly generate a PAT (and save it enterprise_PAT.txt ) and point RepoAuditor to the corresponding repo: uvx repoauditor --includes GitHub \\ --GitHub-url <url-to-enterprise-repo> \\ --GitHub-pat ~/enterprise_PAT.txt As a general example, we will use the python-helloworld repository. NOTE You need to fork the repository since your default PAT only has access to repos under your account. To run RepoAuditor , we can enter the following in the command-line: uvx repoauditor --includes GitHub \\ --GitHub-url https://github.com/<username>/python-helloworld \\ --GitHub-pat ~/PAT.txt RepoAuditor will generate a series of messages describing all the issues in the repository, along with the rationale behind them and the steps for resolution.","title":"Basic Use"},{"location":"usage/#custom-settings","text":"RepoAuditor tries to provide default settings and checks which are considered best practices. However, your team or organization may have different ways of doing things. You can override the default settings by specifying the appropriate flag. We have 3 types of flags: Boolean flags for those settings which are checked to be on by default and you wish to check are off, with the form Module-no-Requirement (e.g. --GitHub-no-MergeCommit ). Conversely, boolean flags for those settings which are checked to be off by default, and you wish to check are on, denoted by the form Module-Requirement (e.g. --GitHub-AllowDeletions ). Values flags take a string value to determine what value to enforce, and have the form Module-Requirement-value (e.g. --GitHub-License-value \"MIT License\" ). Please run uvx repoauditor --help to get the list of all flags available.","title":"Custom Settings"},{"location":"usage/#examples","text":"In this section, we will look at various exampls of using RepoAuditor . For the sake of brevity, we will omit the --includes and --GitHub-url flags, leaving the inclusion to the user. RepoAuditor is designed to have sensible defaults which represent industry best practices. For example, RepoAuditor by default checks that the setting Allow rebase merging is off. However, if you wish to check that this setting is turned on, you can run: uvx repoauditor --GitHub-RebaseMergeCommit Similarly, RepoAuditor checks if Issues are enabled. You can set RepoAuditor to check if Issues is disabled by specifying uvx repoauditor --GitHub-no-SupportIssues Finally, RepoAuditor by default enforces that the MIT License exists for the repository. If your organization requires another license (such as GPL ), you can enforce that by specifying the license keyword such as: uvx repoauditor --GitHub-License-value \"GNU General Public License v2.0\" The types of licenses supported by GitHub can be found here . Be sure to specify the full license name, e.g. GNU General Public License v2.0 .","title":"Examples"},{"location":"usage/#excluding-requirements","text":"There is often the case you might wish to exclude a module or a specific requirement. RepoAuditor has built-in support for this as well, by using the --excludes flag. To exclude a requirement, you can run specify the requirement as Module-Requirement uvx repoauditor --includes GitHub --excludes GitHub-RequireSignedCommitsRule The above command includes all of the requirements in the GitHub module except for the RequireSignedCommitsRule requirement. You can similarly exclude a whole module: uvx repoauditor --includes GitHub --excludes CommunityStandards NOTE: This way of excluding a module is redundant since any module not added via --includes is automatically excluded.","title":"Excluding Requirements"}]}